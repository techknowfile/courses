!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ALLOC	project5.h	2;"	d
ARRAY	compiler.h	29;"	d
ASSIGN_STMT	compiler.h	/^    ASSIGN_STMT,$/;"	e	enum:StatementType
AssignmentStatement	compiler.h	/^struct AssignmentStatement$/;"	s
CASE	compiler.h	26;"	d
COLON	compiler.h	35;"	d
COMMA	compiler.h	36;"	d
DEBUG	compiler.c	8;"	d	file:
DEFAULT	compiler.h	27;"	d
DIV	compiler.h	32;"	d
EQUAL	compiler.h	34;"	d
ERROR	compiler.h	49;"	d
FALSE	compiler.h	9;"	d
GOTO_STMT	compiler.h	/^    GOTO_STMT$/;"	e	enum:StatementType
GREATER	compiler.h	45;"	d
GotoStatement	compiler.h	/^struct GotoStatement$/;"	s
ID	compiler.h	47;"	d
IF	compiler.h	23;"	d
IF_STMT	compiler.h	/^    IF_STMT,$/;"	e	enum:StatementType
IfStatement	compiler.h	/^struct IfStatement$/;"	s
KEYWORDS	compiler.h	20;"	d
LBRAC	compiler.h	38;"	d
LBRACE	compiler.h	42;"	d
LESS	compiler.h	46;"	d
LPAREN	compiler.h	40;"	d
MAX_TOKEN_LENGTH	compiler.h	53;"	d
MINUS	compiler.h	31;"	d
MULT	compiler.h	33;"	d
MatchesName	project5.cpp	/^	    MatchesName(const std::string &name) : _name(name) {}$/;"	f	class:MatchesName
MatchesName	project5.cpp	/^class MatchesName$/;"	c	file:
NOOP_STMT	compiler.h	/^    NOOP_STMT = 1000,$/;"	e	enum:StatementType
NOTEQUAL	compiler.h	44;"	d
NUM	compiler.h	48;"	d
PLUS	compiler.h	30;"	d
PRINT	compiler.h	28;"	d
PRINT_STMT	compiler.h	/^    PRINT_STMT,$/;"	e	enum:StatementType
PrintStatement	compiler.h	/^struct PrintStatement$/;"	s
RBRAC	compiler.h	39;"	d
RBRACE	compiler.h	43;"	d
RESERVED	compiler.h	21;"	d
RPAREN	compiler.h	41;"	d
SEMICOLON	compiler.h	37;"	d
SWITCH	compiler.h	25;"	d
StatementNode	compiler.h	/^struct StatementNode$/;"	s
StatementType	compiler.h	/^enum StatementType$/;"	g
TRUE	compiler.h	8;"	d
VAR	compiler.h	22;"	d
ValueNode	compiler.h	/^struct ValueNode$/;"	s
WHILE	compiler.h	24;"	d
_COMPILER_H_	compiler.h	2;"	d
_name	project5.cpp	/^    std::string _name;$/;"	m	class:MatchesName	file:
activeToken	compiler.c	/^int  activeToken = FALSE;$/;"	v
assign_stmt	compiler.h	/^        struct AssignmentStatement* assign_stmt;$/;"	m	union:StatementNode::__anon1	typeref:struct:StatementNode::__anon1::AssignmentStatement
condition_op	compiler.h	/^    int condition_op;$/;"	m	struct:IfStatement
condition_operand1	compiler.h	/^    struct ValueNode* condition_operand1;$/;"	m	struct:IfStatement	typeref:struct:IfStatement::ValueNode
condition_operand2	compiler.h	/^    struct ValueNode* condition_operand2;$/;"	m	struct:IfStatement	typeref:struct:IfStatement::ValueNode
debug	compiler.c	/^void debug(const char * format, ...)$/;"	f
execute_program	compiler.c	/^void execute_program(struct StatementNode* program)$/;"	f
false_branch	compiler.h	/^    struct StatementNode* false_branch;$/;"	m	struct:IfStatement	typeref:struct:IfStatement::StatementNode
getToken	compiler.c	/^int getToken()$/;"	f
get_last_statement_node	project5.cpp	/^struct StatementNode* get_last_statement_node(struct StatementNode* stmt){$/;"	f
goto_stmt	compiler.h	/^        struct GotoStatement* goto_stmt;$/;"	m	union:StatementNode::__anon1	typeref:struct:StatementNode::__anon1::GotoStatement
id	compiler.h	/^    struct ValueNode* id;$/;"	m	struct:PrintStatement	typeref:struct:PrintStatement::ValueNode
if_stmt	compiler.h	/^        struct IfStatement* if_stmt;$/;"	m	union:StatementNode::__anon1	typeref:struct:StatementNode::__anon1::IfStatement
isKeyword	compiler.c	/^int isKeyword(char *s)$/;"	f
left_hand_side	compiler.h	/^    struct ValueNode* left_hand_side;$/;"	m	struct:AssignmentStatement	typeref:struct:AssignmentStatement::ValueNode
line_no	compiler.c	/^int  line_no = 1;$/;"	v
main	compiler.c	/^int main()$/;"	f
name	compiler.h	/^    char* name;$/;"	m	struct:ValueNode
next	compiler.h	/^    struct StatementNode* next; \/\/ next statement in the list or NULL$/;"	m	struct:StatementNode	typeref:struct:StatementNode::StatementNode
num2ValNode	project5.cpp	/^struct ValueNode* num2ValNode(){$/;"	f
op	compiler.h	/^    int op;$/;"	m	struct:AssignmentStatement
operand1	compiler.h	/^    struct ValueNode* operand1;$/;"	m	struct:AssignmentStatement	typeref:struct:AssignmentStatement::ValueNode
operand2	compiler.h	/^    struct ValueNode* operand2;$/;"	m	struct:AssignmentStatement	typeref:struct:AssignmentStatement::ValueNode
operator ()	project5.cpp	/^	    bool operator()(ValueNode* &item) const$/;"	f	class:MatchesName
parse_assign_stmt	project5.cpp	/^struct AssignmentStatement* parse_assign_stmt(){$/;"	f
parse_body	project5.cpp	/^struct StatementNode* parse_body(){$/;"	f
parse_case	project5.cpp	/^struct StatementNode* parse_case(struct ValueNode* val){$/;"	f
parse_case_list	project5.cpp	/^struct StatementNode* parse_case_list(struct ValueNode* val, struct StatementNode* noop_node){$/;"	f
parse_condition	project5.cpp	/^void parse_condition(struct IfStatement* condition){$/;"	f
parse_generate_intermediate_representation	project5.cpp	/^struct StatementNode* parse_generate_intermediate_representation(){$/;"	f
parse_id	project5.cpp	/^struct ValueNode* parse_id(){$/;"	f
parse_id_list	project5.cpp	/^void parse_id_list(){$/;"	f
parse_primary	project5.cpp	/^struct ValueNode* parse_primary(){$/;"	f
parse_print_stmt	project5.cpp	/^struct PrintStatement* parse_print_stmt(){$/;"	f
parse_stmt	project5.cpp	/^struct StatementNode* parse_stmt(){$/;"	f
parse_stmt_list	project5.cpp	/^struct StatementNode* parse_stmt_list(){$/;"	f
parse_switch	project5.cpp	/^struct StatementNode* parse_switch(){$/;"	f
parse_var_section	project5.cpp	/^void parse_var_section(){$/;"	f
print_stmt	compiler.h	/^        struct PrintStatement* print_stmt;$/;"	m	union:StatementNode::__anon1	typeref:struct:StatementNode::__anon1::PrintStatement
reserved	compiler.c	/^char *reserved[] =$/;"	v
scan_id_or_keyword	compiler.c	/^int scan_id_or_keyword()$/;"	f
scan_number	compiler.c	/^int scan_number()$/;"	f
skipSpace	compiler.c	/^void skipSpace()$/;"	f
target	compiler.h	/^    struct StatementNode* target;$/;"	m	struct:GotoStatement	typeref:struct:GotoStatement::StatementNode
token	compiler.c	/^char token[MAX_TOKEN_LENGTH];      \/\/ token string$/;"	v
tokenLength	compiler.c	/^int  tokenLength;$/;"	v
true_branch	compiler.h	/^    struct StatementNode* true_branch;$/;"	m	struct:IfStatement	typeref:struct:IfStatement::StatementNode
ttype	compiler.c	/^int  ttype;                        \/\/ token type$/;"	v
type	compiler.h	/^    enum StatementType type;$/;"	m	struct:StatementNode	typeref:enum:StatementNode::StatementType
ungetToken	compiler.c	/^void ungetToken()$/;"	f
value	compiler.h	/^    int   value;$/;"	m	struct:ValueNode
